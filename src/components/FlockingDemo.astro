<div class="flocking-container">
  <div id="flocking-canvas"></div>
</div>

<script>
  import { Agent, Environment, CanvasRenderer, Vector, KDTree, utils } from 'flocc';

  const canvas = document.getElementById("flocking-canvas");
  const { width, height } = canvas.parentElement.getBoundingClientRect();
  const environment = new Environment({ width, height });
  let kdtree = null;
  let animationID = -1;
  
  const tick = (agent) => {
    const dir = new Vector(agent.get("vx"), agent.get("vy"));
    agent.set("x", (agent.get("x") + dir.x) % width);
    agent.set("y", (agent.get("y") + dir.y) % height);

    const { x, y } = agent.getData();
    const step = new Vector();
    const threshold = 40;
    /*
    const neighbors = kdtree.agentsWithinDistance(agent, threshold);
    if (neighbors.length === 0) return;

    const v = n => Math.min(1, threshold / n);
    neighbors.forEach(neighbor => {
      const away = new Vector(
        v(x - neighbor.get("x")),
        v(y - neighbor.get("y"))
      );
      away.normalize().multiplyScalar(0.03);
      step.add(away);
    });
    */

    dir.add(step);
    dir.multiplyScalar(dir.length() > 1 ? 0.97 : 1.03);
    agent.set("vx", dir.x);
    agent.set("vy", dir.y);
  };

  const renderer = new CanvasRenderer(environment, {
    width,
    height
  });
  renderer.mount("#flocking-canvas");

  for (let i = 0; i < width / 8; i++) {
    const agent = new Agent();
    const angle = 2 * Math.PI * Math.random();
    const dir = new Vector(Math.cos(angle), Math.sin(angle));
    dir.normalize();
    agent.set("vx", dir.x);
    agent.set("vy", dir.y);
    agent.set("x", Math.random() * width);
    agent.set("y", Math.random() * height);
    agent.set("color", `rgb(0, ${utils.random(0, 255)}, ${utils.random(127, 255)})`);
    agent.set("shape", "arrow");
    agent.set("size", Math.random() * 3 + 2);
    agent.set("tick", tick);
    environment.addAgent(agent);
  }
  kdtree = new KDTree(environment.getAgents(), 2);
  environment.use(kdtree);

  const update = () => {
    environment.tick();
    animationID = window.requestAnimationFrame(update);
  };

  update();

  const onMouseMove = (e) => {
    const { clientX, clientY, movementX, movementY } = e;

    const mouse = {
      x: clientX - e.currentTarget.getBoundingClientRect().left,
      y: clientY - e.currentTarget.getBoundingClientRect().top
    };

    const nearby = kdtree.agentsWithinDistance(mouse, 100);
    nearby.forEach(agent => {
      const d = utils.distance(mouse, agent);
      const inverseDistance = Math.min(0.1, 1 / d);
      agent.increment("vx", movementX * inverseDistance);
      agent.increment("vy", movementY * inverseDistance);
      agent.set("x", (agent.get("x") + 20 * inverseDistance * movementX) % width);
      agent.set("y", (agent.get("y") + 20 * inverseDistance * movementY) % height);
    });
  };

  canvas.addEventListener("mousemove", onMouseMove);
</script>

<style>
  .flocking-container {
    width: 100%;
    height: 500px;
  }

  #flocking-canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>
